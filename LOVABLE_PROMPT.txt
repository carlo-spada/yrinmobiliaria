# DATABASE SCHEMA REFACTOR - Fix Data Integrity Issues

## Problem Summary

We have several critical database schema issues:
1. Duplicate role assignments (user has 2 identical superadmin roles due to NULL handling)
2. No foreign key between role_assignments and profiles (cannot JOIN in queries)
3. No automatic profile creation (inconsistent data, orphaned roles)
4. Email not synced between auth.users and profiles
5. Unclear user lifecycle causing consistency issues

## Solution: 5 Database Changes

Execute these SQL changes in the exact order below:

---

### STEP 1: Clean Up Duplicate Roles (Run First!)

```sql
-- Remove duplicate role assignments (keep most recent)
WITH duplicates AS (
  SELECT
    id,
    ROW_NUMBER() OVER (
      PARTITION BY
        user_id,
        role,
        COALESCE(organization_id::text, '__GLOBAL__')
      ORDER BY granted_at DESC NULLS LAST, created_at DESC NULLS LAST
    ) as row_num
  FROM role_assignments
)
DELETE FROM role_assignments
WHERE id IN (
  SELECT id FROM duplicates WHERE row_num > 1
);

-- Verify cleanup
SELECT
  user_id,
  role,
  COALESCE(organization_id::text, 'GLOBAL') as org,
  COUNT(*) as count
FROM role_assignments
GROUP BY user_id, role, COALESCE(organization_id::text, 'GLOBAL')
HAVING COUNT(*) > 1;
-- Should return 0 rows
```

---

### STEP 2: Fix UNIQUE Constraint

```sql
-- Remove old constraint that allows NULL duplicates
ALTER TABLE role_assignments DROP CONSTRAINT IF EXISTS unique_user_org_role;

-- Add new constraint that treats NULL as a specific value
CREATE UNIQUE INDEX idx_unique_role_per_user_org
ON role_assignments (
  user_id,
  role,
  COALESCE(organization_id::text, '__GLOBAL__')
);

-- Verify constraint works
SELECT
  conname as constraint_name,
  contype as constraint_type
FROM pg_constraint
WHERE conrelid = 'role_assignments'::regclass
  AND conname LIKE '%unique%';
```

---

### STEP 3: Auto-Create Profile on Signup

```sql
-- Function to handle new user signup
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  default_display_name TEXT;
  yr_org_id UUID;
BEGIN
  default_display_name := SPLIT_PART(NEW.email, '@', 1);
  SELECT id INTO yr_org_id FROM organizations WHERE slug = 'yr-inmobiliaria';

  -- Create profile automatically
  INSERT INTO public.profiles (
    user_id,
    email,
    display_name,
    is_complete,
    email_verified,
    created_at,
    updated_at
  ) VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'display_name', default_display_name),
    false,
    COALESCE(NEW.email_confirmed_at IS NOT NULL, false),
    NOW(),
    NOW()
  ) ON CONFLICT (user_id) DO NOTHING;

  -- Auto-assign default 'user' role
  INSERT INTO public.role_assignments (
    user_id,
    role,
    granted_at
  ) VALUES (
    NEW.id,
    'user',
    NOW()
  ) ON CONFLICT DO NOTHING;

  -- Auto-admin for Carlo and Yas
  IF NEW.email = 'carlo.spada22@gmail.com' THEN
    INSERT INTO public.role_assignments (user_id, organization_id, role, granted_at)
    VALUES (NEW.id, NULL, 'superadmin', NOW())
    ON CONFLICT DO NOTHING;
  ELSIF NEW.email = 'ruizvasquezyazmin@gmail.com' AND yr_org_id IS NOT NULL THEN
    INSERT INTO public.role_assignments (user_id, organization_id, role, granted_at)
    VALUES (NEW.id, yr_org_id, 'admin', NOW())
    ON CONFLICT DO NOTHING;
    UPDATE public.profiles SET organization_id = yr_org_id, updated_at = NOW() WHERE user_id = NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Attach trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user();

-- Verify trigger exists
SELECT
  trigger_name,
  event_manipulation,
  event_object_table
FROM information_schema.triggers
WHERE trigger_name = 'on_auth_user_created';
```

---

### STEP 4: Add Foreign Key to Profiles

```sql
-- Add FK to ensure referential integrity
ALTER TABLE role_assignments
ADD CONSTRAINT fk_role_assignments_profiles
FOREIGN KEY (user_id)
REFERENCES profiles(user_id)
ON DELETE CASCADE
DEFERRABLE INITIALLY DEFERRED;

-- Verify FK exists
SELECT
  tc.constraint_name,
  kcu.column_name,
  ccu.table_name AS foreign_table,
  ccu.column_name AS foreign_column
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = 'role_assignments'
  AND kcu.column_name = 'user_id'
  AND ccu.table_name = 'profiles';
-- Should return 1 row
```

---

### STEP 5: Sync Email Changes

```sql
-- Function to sync email
CREATE OR REPLACE FUNCTION sync_user_email()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.email IS DISTINCT FROM OLD.email THEN
    UPDATE public.profiles
    SET email = NEW.email, updated_at = NOW()
    WHERE user_id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Attach trigger
DROP TRIGGER IF EXISTS on_auth_user_email_changed ON auth.users;
CREATE TRIGGER on_auth_user_email_changed
  AFTER UPDATE ON auth.users
  FOR EACH ROW
  WHEN (OLD.email IS DISTINCT FROM NEW.email)
  EXECUTE FUNCTION sync_user_email();

-- Verify trigger exists
SELECT
  trigger_name,
  event_manipulation,
  event_object_table
FROM information_schema.triggers
WHERE trigger_name = 'on_auth_user_email_changed';
```

---

## Final Verification

Run these queries to confirm everything worked:

```sql
-- 1. No duplicate roles
SELECT user_id, role, COALESCE(organization_id::text, 'GLOBAL') as org, COUNT(*)
FROM role_assignments
GROUP BY user_id, role, COALESCE(organization_id::text, 'GLOBAL')
HAVING COUNT(*) > 1;
-- Expected: 0 rows

-- 2. All roles have profiles
SELECT COUNT(*)
FROM role_assignments ra
LEFT JOIN profiles p ON ra.user_id = p.user_id
WHERE p.user_id IS NULL;
-- Expected: 0

-- 3. Carlo has exactly 1 superadmin
SELECT COUNT(*)
FROM role_assignments ra
JOIN auth.users u ON ra.user_id = u.id
WHERE u.email = 'carlo.spada22@gmail.com' AND ra.role = 'superadmin';
-- Expected: 1

-- 4. Triggers exist
SELECT trigger_name, event_object_table
FROM information_schema.triggers
WHERE trigger_name IN ('on_auth_user_created', 'on_auth_user_email_changed');
-- Expected: 2 rows
```

---

## Success Criteria

After running all steps:
âœ… Carlo should have exactly 1 superadmin role (not 2)
âœ… Can JOIN role_assignments with profiles in queries
âœ… New user signups auto-create profiles + roles
âœ… Email changes sync automatically
âœ… All verification queries pass

## Next Steps

After migration:
1. Update AdminUsers.tsx to use JOIN query (simpler code)
2. Test signup flow with new user
3. Verify admin dashboard displays all users correctly

---

**Execute each STEP in order, verify after each one, and you're done!** ðŸš€
